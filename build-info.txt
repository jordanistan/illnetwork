Absolutely—already added. Here’s an upgraded, production-ready rev that includes **live streaming scan logs in the web UI** (Server-Sent Events) and **alerts** (Slack + email) when issues are detected.

---

# What’s new

* **/scan (button)** now streams logs in real time (no page refresh).
* **Alerts**: triggers if malware is found, rkhunter throws warnings, or the GPT summary flags “High/Critical”.
* **Hardened scanner output**: all scan output goes to both the screen **and** a timestamped report file.
* **Healthier defaults** with env-configurable thresholds.

---

## Updated directory

```
homelab-security/
├─ scanner/
│  ├─ scan.sh
│  ├─ parse_logs.py
│  ├─ alerts.py
│  └─ requirements.txt
├─ webui/
│  ├─ app.py
│  ├─ templates/
│  │   └─ index.html
│  └─ static/
│      └─ style.css
├─ Dockerfile
├─ docker-compose.yml
└─ README.md
```

---

## scanner/requirements.txt (merged for web + scanner)

```txt
Flask==3.0.3
Werkzeug>=3.0.0
openai>=0.28.0
requests>=2.32.3
```

---

## scanner/scan.sh (streams + saves)

```bash
#!/bin/bash
set -euo pipefail

OUTPUT_DIR="${OUTPUT_DIR:-/opt/data/reports}"
mkdir -p "$OUTPUT_DIR"
TIMESTAMP=$(date +%Y%m%d_%H%M%S)
REPORT_FILE="$OUTPUT_DIR/report_${TIMESTAMP}.txt"

# Mirror all stdout+stderr to both console (for live stream) and file
exec > >(tee -a "$REPORT_FILE") 2>&1

echo "=== Homelab Security Scan ==="
echo "Started: $(date -Is)"
echo "Report file: $REPORT_FILE"
echo "--------------------------------------"

# Update AV defs if possible (non-fatal if it fails)
if command -v freshclam >/dev/null 2>&1; then
  echo "[*] Updating ClamAV defs (freshclam)..."
  freshclam || echo "[!] freshclam update failed (continuing)."
fi

# 1. Malware scan (may be noisy—scoped to /opt/data by default; override SCAN_PATH=/)
SCAN_PATH="${SCAN_PATH:-/opt/data}"
echo "[*] Running ClamAV scan on: $SCAN_PATH"
clamscan -r --bell -i "$SCAN_PATH" || true

# 2. Rootkit scan
echo "[*] Running rkhunter rootkit check..."
# Try to initialize property db on first run; non-fatal
rkhunter --propupd || true
rkhunter --check --sk || true

# 3. Network audit
echo "[*] Scanning network services..."
if command -v ss >/dev/null 2>&1; then
  ss -tulpn
else
  netstat -tulpn
fi

# 4. Credential & secret scan (lightweight heuristics)
echo "[*] Scanning for exposed credentials..."
# shellcheck disable=SC2144
find /home /etc -type f \( -name "*id_rsa*" -o -name "*.pem" -o -name "*.key" -o -name "*.token" -o -name "*.env" \) 2>/dev/null | sed 's/^/CRED: /'

echo "--------------------------------------"
echo "Completed: $(date -Is)"
echo "[*] Scan complete. Report saved to $REPORT_FILE"

# Emit a single machine-readable line to help the web UI pick up the file
echo "__REPORT_FILE__=$REPORT_FILE"
```

> Default scan path is `/opt/data` to keep container runs fast/safe. Set `SCAN_PATH=/` in the compose env if you want full depth.

---

## scanner/alerts.py (Slack + email helpers)

```python
import os
import smtplib
import ssl
from email.message import EmailMessage
import requests

SLACK_WEBHOOK_URL = os.getenv("SLACK_WEBHOOK_URL")
ALERT_EMAIL_TO = os.getenv("ALERT_EMAIL_TO")
ALERT_EMAIL_FROM = os.getenv("ALERT_EMAIL_FROM", ALERT_EMAIL_TO or "alerts@example.local")

SMTP_HOST = os.getenv("SMTP_HOST")
SMTP_PORT = int(os.getenv("SMTP_PORT", "587"))
SMTP_USER = os.getenv("SMTP_USER")
SMTP_PASS = os.getenv("SMTP_PASS")
SMTP_STARTTLS = os.getenv("SMTP_STARTTLS", "true").lower() == "true"

def send_slack(text: str):
    if not SLACK_WEBHOOK_URL:
        return
    try:
        requests.post(SLACK_WEBHOOK_URL, json={"text": text}, timeout=10)
    except Exception:
        pass  # don't crash on alert failures

def send_email(subject: str, body: str):
    if not (SMTP_HOST and ALERT_EMAIL_TO):
        return
    msg = EmailMessage()
    msg["Subject"] = subject
    msg["From"] = ALERT_EMAIL_FROM
    msg["To"] = ALERT_EMAIL_TO
    msg.set_content(body)

    context = ssl.create_default_context()
    if SMTP_STARTTLS:
        with smtplib.SMTP(SMTP_HOST, SMTP_PORT) as s:
            s.ehlo()
            s.starttls(context=context)
            if SMTP_USER and SMTP_PASS:
                s.login(SMTP_USER, SMTP_PASS)
            s.send_message(msg)
    else:
        with smtplib.SMTP_SSL(SMTP_HOST, SMTP_PORT, context=context) as s:
            if SMTP_USER and SMTP_PASS:
                s.login(SMTP_USER, SMTP_PASS)
            s.send_message(msg)

def notify(subject: str, body: str):
    send_slack(f"*{subject}*\n{body}")
    send_email(subject, body)
```

---

## scanner/parse_logs.py (keeps your GPT report + adds alert heuristics)

```python
import os
import datetime
import json
import re
import openai

from alerts import notify

OPENAI_API_KEY = os.environ.get("OPENAI_API_KEY")
REPORT_DIR = os.environ.get("OUTPUT_DIR", "/opt/data/reports")
ALERT_SEVERITY_THRESHOLD = os.getenv("ALERT_SEVERITY_THRESHOLD", "high").lower()  # low|medium|high|critical

SEVERITY_ORDER = {"low": 1, "medium": 2, "high": 3, "critical": 4}

def find_latest_scan():
    files = [f for f in os.listdir(REPORT_DIR) if f.startswith("report_") and f.endswith(".txt")]
    files.sort()
    return os.path.join(REPORT_DIR, files[-1]) if files else None

def extract_simple_indicators(scan_text: str):
    # ClamAV infections
    infected = len(re.findall(r"\bFOUND\b", scan_text))
    # rkhunter warnings
    rk_warn = len(re.findall(r"\bWarning\b", scan_text, flags=re.IGNORECASE))
    # Credential hits (we prefixed with CRED:)
    cred_hits = len(re.findall(r"^CRED:", scan_text, flags=re.MULTILINE))
    return infected, rk_warn, cred_hits

def gpt_summary(scan_text: str):
    if not OPENAI_API_KEY:
        return "OpenAI API key not set. Skipping GPT summary."
    openai.api_key = OPENAI_API_KEY
    prompt = f"""
You are a professional cybersecurity analyst.
Analyze the following scan results and generate a detailed report with sections:

1. Findings (bullet list)
2. Severity rating for each finding (Low/Medium/High/Critical)
3. How to fix (actionable steps/commands)
4. How to prevent future issues (policy/config hardening)
5. High-level summary for non-technical users

Scan log:
{scan_text}
"""
    # Keeping your original call pattern for compatibility
    resp = openai.ChatCompletion.create(
        model="gpt-4",
        messages=[{"role": "user", "content": prompt}],
        temperature=0.2,
    )
    return resp["choices"][0]["message"]["content"]

def save_reports(summary: str, base_filename: str):
    md_file = os.path.join(REPORT_DIR, base_filename + ".md")
    html_file = os.path.join(REPORT_DIR, base_filename + ".html")
    json_file = os.path.join(REPORT_DIR, base_filename + ".json")

    with open(md_file, "w") as f:
        f.write(summary)

    html_content = f"<html><head><meta charset='utf-8'></head><body><pre>{summary}</pre></body></html>"
    with open(html_file, "w") as f:
        f.write(html_content)

    with open(json_file, "w") as f:
        json.dump({"report": summary}, f, indent=2)

    return md_file, html_file, json_file

def derive_overall_severity(summary_text: str, infected: int, rk_warn: int) -> str:
    # Use heuristics + summary keywords
    sev = "low"
    if infected > 0 or rk_warn > 0:
        sev = "high" if infected == 0 else "critical"
    # Try to upgrade based on GPT text
    if re.search(r"\bCritical\b", summary_text, re.IGNORECASE):
        sev = "critical"
    elif re.search(r"\bHigh\b", summary_text, re.IGNORECASE):
        sev = max(sev, "high", key=lambda s: SEVERITY_ORDER[s])
    elif re.search(r"\bMedium\b", summary_text, re.IGNORECASE):
        sev = max(sev, "medium", key=lambda s: SEVERITY_ORDER[s])
    return sev

if __name__ == "__main__":
    latest_scan = find_latest_scan()
    if not latest_scan:
        print("No scan logs found.")
        exit(1)

    with open(latest_scan, "r", errors="replace") as f:
        scan_text = f.read()

    infected, rk_warn, cred_hits = extract_simple_indicators(scan_text)
    summary = gpt_summary(scan_text)
    base_filename = f"gpt_summary_{datetime.datetime.now().strftime('%Y%m%d_%H%M%S')}"
    md_file, html_file, json_file = save_reports(summary, base_filename)

    overall = derive_overall_severity(summary, infected, rk_warn)
    threshold_ok = SEVERITY_ORDER.get(overall, 1) >= SEVERITY_ORDER.get(ALERT_SEVERITY_THRESHOLD, 3)

    if threshold_ok:
        body = (
            f"Overall severity: {overall.upper()}\n"
            f"Infected files: {infected}\n"
            f"rkhunter warnings: {rk_warn}\n"
            f"Credential hits: {cred_hits}\n\n"
            f"Scan log: {latest_scan}\n"
            f"Reports:\n- {md_file}\n- {html_file}\n- {json_file}\n"
        )
        notify("Homelab Security Alert", body)

    print(f"Reports saved:\n- {md_file}\n- {html_file}\n- {json_file}")
    print(f"Overall severity: {overall}")
```

---

## webui/app.py (SSE live stream + small API)

```python
from flask import Flask, render_template, request, send_from_directory, Response, jsonify
import subprocess
import os
import time
import shlex

REPORT_DIR = os.environ.get("OUTPUT_DIR", "/opt/data/reports")
SCANNER = "/opt/scanner/scan.sh"
PARSER = "/opt/scanner/parse_logs.py"

app = Flask(__name__)

def list_reports():
    if not os.path.isdir(REPORT_DIR):
        return []
    return sorted(os.listdir(REPORT_DIR), reverse=True)

@app.route("/")
def index():
    reports = [r for r in list_reports() if not r.endswith(".txt")]  # hide raw TXT by default
    return render_template("index.html", reports=reports)

@app.route("/scan", methods=["GET"])
def scan_page():
    # The page hosts a live log window; stream is below
    return render_template("index.html", reports=[r for r in list_reports() if not r.endswith(".txt")], autostart=True)

@app.route("/scan/stream")
def scan_stream():
    def generate():
        # Run scanner with line-buffered stdout
        cmd = f"stdbuf -oL -eL bash {shlex.quote(SCANNER)}"
        proc = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, shell=True, text=True, bufsize=1)
        report_file = None

        for line in proc.stdout:
            line = line.rstrip("\n")
            # Capture emitted file path marker from scan.sh
            if line.startswith("__REPORT_FILE__="):
                report_file = line.split("=", 1)[1]
            yield f"data: {line}\n\n"

        proc.wait()

        # Generate GPT reports after scan finishes
        yield f"data: === Generating GPT summary ===\n\n"
        try:
            p2 = subprocess.run(["python3", PARSER], capture_output=True, text=True, check=False)
            for out_line in p2.stdout.splitlines():
                yield f"data: {out_line}\n\n"
            if p2.stderr:
                for err_line in p2.stderr.splitlines():
                    yield f"data: [ERR] {err_line}\n\n"
        except Exception as e:
            yield f"data: [ERR] parse step failed: {e}\n\n"

        yield "event: done\ndata: complete\n\n"

    return Response(generate(), mimetype="text/event-stream")

@app.route("/reports/<path:filename>")
def get_report(filename):
    return send_from_directory(REPORT_DIR, filename)

@app.route("/api/reports")
def api_reports():
    return jsonify([f for f in list_reports()])

if __name__ == "__main__":
    os.makedirs(REPORT_DIR, exist_ok=True)
    app.run(host="0.0.0.0", port=5000, threaded=True)
```

---

## webui/templates/index.html (live console UI)

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Homelab Security Scanner</title>
  <link rel="stylesheet" href="/static/style.css">
</head>
<body>
  <header>
    <h1>Homelab Security Scanner</h1>
    <button id="runBtn">Run New Scan (live)</button>
  </header>

  <section>
    <h2>Live Output</h2>
    <pre id="log" class="terminal"></pre>
  </section>

  <section>
    <h2>Available Reports</h2>
    <ul id="reportList">
      {% for report in reports %}
        <li><a href="/reports/{{ report }}" target="_blank">{{ report }}</a></li>
      {% endfor %}
    </ul>
  </section>

  <script>
    const runBtn = document.getElementById('runBtn');
    const logEl = document.getElementById('log');
    const reportList = document.getElementById('reportList');

    function append(line) {
      logEl.textContent += (line + "\n");
      logEl.scrollTop = logEl.scrollHeight;
    }

    async function refreshReports() {
      const r = await fetch('/api/reports');
      const data = await r.json();
      reportList.innerHTML = '';
      data.filter(x => !x.endsWith('.txt')).forEach(name => {
        const li = document.createElement('li');
        const a = document.createElement('a');
        a.href = '/reports/' + name;
        a.target = '_blank';
        a.textContent = name;
        li.appendChild(a);
        reportList.appendChild(li);
      });
    }

    function startScan() {
      runBtn.disabled = true;
      logEl.textContent = '';
      const sse = new EventSource('/scan/stream');
      sse.onmessage = (e) => append(e.data);
      sse.addEventListener('done', async () => {
        append('=== Scan complete ===');
        sse.close();
        await refreshReports();
        runBtn.disabled = false;
      });
      sse.onerror = () => {
        append('[ERR] stream error');
        sse.close();
        runBtn.disabled = false;
      };
    }

    runBtn.addEventListener('click', startScan);

    {% if autostart %}
      startScan();
    {% endif %}
  </script>
</body>
</html>
```

---

## webui/static/style.css (minimal aesthetic)

```css
body { font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, sans-serif; color: #e5e7eb; background: #0b1220; margin: 0; }
header { display: flex; align-items: center; justify-content: space-between; padding: 16px 20px; background: #0f172a; border-bottom: 1px solid #1f2937; }
h1, h2 { margin: 12px 0; }
section { padding: 16px 20px; }
#runBtn { background: #2563eb; color: white; border: 0; padding: 10px 14px; border-radius: 10px; cursor: pointer; }
#runBtn:disabled { opacity: 0.6; cursor: not-allowed; }
.terminal { background: #0a0f1a; border: 1px solid #1f2937; padding: 12px; border-radius: 12px; height: 42vh; overflow: auto; }
a { color: #93c5fd; text-decoration: none; }
a:hover { text-decoration: underline; }
ul { list-style: none; padding: 0; }
li { padding: 6px 0; }
```

---

## Dockerfile (unchanged base + stdbuf)

```dockerfile
FROM python:3.12-slim

# Tools
RUN apt-get update && apt-get install -y --no-install-recommends \
    clamav clamav-freshclam rkhunter net-tools iproute2 procps \
    coreutils findutils ca-certificates curl sudo tini \
    && rm -rf /var/lib/apt/lists/*

# Python deps
COPY scanner/requirements.txt /tmp/requirements.txt
RUN pip install --no-cache-dir -r /tmp/requirements.txt

# Copy code
COPY scanner /opt/scanner
COPY webui /opt/webui

ENV OUTPUT_DIR=/opt/data/reports
RUN mkdir -p ${OUTPUT_DIR}

WORKDIR /opt/webui
EXPOSE 5000

ENTRYPOINT ["/usr/bin/tini","--"]
CMD ["python","app.py"]
```

---

## docker-compose.yml (env for alerts + knobs)

```yaml
version: "3.9"
services:
  homelab-security:
    build: .
    container_name: homelab-security
    ports:
      - "5000:5000"
    environment:
      - OPENAI_API_KEY=${OPENAI_API_KEY}
      - OUTPUT_DIR=/opt/data/reports
      - SCAN_PATH=${SCAN_PATH:-/opt/data}
      - ALERT_SEVERITY_THRESHOLD=${ALERT_SEVERITY_THRESHOLD:-high}
      # Slack (optional)
      - SLACK_WEBHOOK_URL=${SLACK_WEBHOOK_URL}
      # Email (optional)
      - ALERT_EMAIL_TO=${ALERT_EMAIL_TO}
      - ALERT_EMAIL_FROM=${ALERT_EMAIL_FROM}
      - SMTP_HOST=${SMTP_HOST}
      - SMTP_PORT=${SMTP_PORT:-587}
      - SMTP_USER=${SMTP_USER}
      - SMTP_PASS=${SMTP_PASS}
      - SMTP_STARTTLS=${SMTP_STARTTLS:-true}
    volumes:
      - ./data:/opt/data
    restart: unless-stopped
```

---

## README.md (quick start excerpt)

````md
# Homelab Security Scanner (Live + Alerts)

### Run
```bash
export OPENAI_API_KEY=sk-...
# optional alerts
export SLACK_WEBHOOK_URL="https://hooks.slack.com/services/..."
export ALERT_EMAIL_TO="you@example.com"
export SMTP_HOST="smtp.example.com"
export SMTP_USER="smtp-user"
export SMTP_PASS="smtp-pass"

docker-compose up --build -d
````

Open [http://localhost:5000](http://localhost:5000) → **Run New Scan (live)**

**Knobs**

* `SCAN_PATH=/` to scan the whole FS (heavier). Default: `/opt/data`.
* `ALERT_SEVERITY_THRESHOLD=medium|high|critical` (default `high`).

**Outputs**

* Raw log: `report_YYYYMMDD_HHMMSS.txt`
* GPT summary: `.md`, `.html`, `.json` saved alongside the log.

**Alerts fire when:**

* ClamAV finds any `FOUND`.
* rkhunter prints `Warning`.
* GPT report includes “High” or “Critical” (threshold-controlled).

```

---

If you’d like, I can add **role-based API tokens** for starting scans, **basic auth** for the UI, and a **Prometheus gauge** for last severity + counts (so you can graph it in Grafana).
```

